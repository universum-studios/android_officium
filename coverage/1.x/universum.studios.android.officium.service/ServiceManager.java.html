<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ServiceManager.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=0;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">debugAndroidTest</a> &gt; <a href="index.source.html" class="el_package">universum.studios.android.officium.service</a> &gt; <span class="el_source">ServiceManager.java</span></div><h1>ServiceManager.java</h1><pre class="source lang-java linenums">/*
 * =================================================================================================
 *                             Copyright (C) 2016 Universum Studios
 * =================================================================================================
 *         Licensed under the Apache License, Version 2.0 or later (further &quot;License&quot; only).
 * -------------------------------------------------------------------------------------------------
 * You may use this file only in compliance with the License. More details and copy of this License
 * you may obtain at
 *
 * 		http://www.apache.org/licenses/LICENSE-2.0
 *
 * You can redistribute, modify or publish any part of the code written within this file but as it
 * is described in the License, the software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES or CONDITIONS OF ANY KIND.
 *
 * See the License for the specific language governing permissions and limitations under the License.
 * =================================================================================================
 */
package universum.studios.android.officium.service;

import android.content.ServiceConnection;
import android.support.annotation.CallSuper;
import android.support.annotation.NonNull;
import android.support.annotation.Nullable;

import java.util.HashMap;
import java.util.Map;

import retrofit2.Retrofit;

/**
 * Manager that may be used for accessing of multiple instances of services (theirs PROXYies) and
 * also of theirs configuration. Each instance of ServiceManager should have its end point specified
 * via {@link #setEndPoint(EndPoint)}. This end point is than attached to each {@link ServiceConnection}
 * object that is created whenever a desired services PROXY instance is requested via {@link #services(Class)}
 * or its configuration is requested via {@link #servicesConfiguration(Class)}.
 * &lt;p&gt;
 * As it is described in {@link ServicesConfiguration} class, each services configuration object
 * caches its services PROXY instance and re-creates it only in case of configuration change. Also
 * ServiceManager caches each instance of these configuration objects and maps them to theirs
 * corresponding services interface.
 *
 * @author Martin Albedinsky
 */
public class ServiceManager {

	/*
	 * Constants ===================================================================================
	 */

	/**
	 * Log TAG.
	 */
	// private static final String TAG = &quot;ServiceManager&quot;;

	/*
	 * Interface ===================================================================================
	 */

	/*
	 * Static members ==============================================================================
	 */

	/*
	 * Members =====================================================================================
	 */

	/**
	 * Map containing services configuration objects mapped to class of services that they configure.
	 */
<span class="fc" id="L71">	private final Map&lt;Class&lt;?&gt;, ServicesConfiguration&gt; mServices = new HashMap&lt;&gt;(1);</span>

	/**
	 * End point for services managed by this manager.
	 */
	private EndPoint mEndPoint;

	/*
	 * Constructors ================================================================================
	 */

	/**
	 * Creates a new instance of ServiceManager without specified end point.
	 *
	 * @see #setEndPoint(EndPoint)
	 */
<span class="fc" id="L87">	public ServiceManager() {</span>
<span class="fc" id="L88">		this.mEndPoint = null;</span>
<span class="fc" id="L89">	}</span>

	/**
	 * Creates a new instance of ServiceManager with the specified &lt;var&gt;endPoint&lt;/var&gt;.
	 *
	 * @param endPoint The desired end point. This end point will be attached to each services
	 *                 configuration created via {@link #onCreateServicesConfiguration(Class)}.
	 * @see #getEndPoint()
	 */
<span class="fc" id="L98">	public ServiceManager(@NonNull final EndPoint endPoint) {</span>
<span class="fc" id="L99">		this.mEndPoint = endPoint;</span>
<span class="fc" id="L100">	}</span>

	/*
	 * Methods =====================================================================================
	 */

	/**
	 * Same as {@link #setEndPoint(EndPoint)} with EndPoint instance providing the given &lt;var&gt;baseUrl&lt;/var&gt;
	 * as its base url via {@link EndPoint#getBaseUrl()}.
	 *
	 * @param baseUrl Base url of the desired end point.
	 */
	public void setEndPoint(@NonNull final String baseUrl) {
<span class="fc" id="L113">		setEndPoint(new EndPoint() {</span>

			/**
			 */
			@NonNull
			@Override
			public String getBaseUrl() {
<span class="fc" id="L120">				return baseUrl;</span>
			}
		});
<span class="fc" id="L123">	}</span>

	/**
	 * Sets an end point for this manager.
	 * &lt;p&gt;
	 * The specified end point will be attached to each services configuration created via
	 * {@link #onCreateServicesConfiguration(Class)}.
	 * &lt;p&gt;
	 * &lt;b&gt;Note&lt;/b&gt; that this will not change end points of the services created prior to this call.
	 *
	 * @param endPoint The desired end point.
	 * @see #getEndPoint()
	 */
	public void setEndPoint(@NonNull final EndPoint endPoint) {
<span class="fc" id="L137">		this.mEndPoint = endPoint;</span>
<span class="fc" id="L138">	}</span>

	/**
	 * Returns the end point specified for this manager.
	 *
	 * @return This manager's end point used for services configuration or {@code null} if no end
	 * point has been specified.
	 */
	@Nullable
	public EndPoint getEndPoint() {
<span class="fc" id="L148">		return mEndPoint;</span>
	}

	/**
	 * Returns the PROXY instance for the requested &lt;var&gt;servicesInterface&lt;/var&gt;. The returned PROXY
	 * can be immediately used for services invocation that are declared by the given services interface.
	 * &lt;p&gt;
	 * Each services interface can be configured via its corresponding configuration object that can
	 * be obtained via {@link #servicesConfiguration(Class)}.
	 *
	 * @param servicesInterface The services interface for which to access its PROXY instance.
	 * @param &lt;S&gt;               Type of the services interface.
	 * @return PROXY for the desired services interface ready for services invocation.
	 * @see #servicesConfiguration(Class)
	 */
	@NonNull
	@SuppressWarnings(&quot;unchecked&quot;)
	public &lt;S&gt; S services(@NonNull final Class&lt;S&gt; servicesInterface) {
<span class="fc" id="L166">		this.ensureHasServicesConfiguration(servicesInterface);</span>
<span class="fc" id="L167">		return (S) mServices.get(servicesInterface).services();</span>
	}

	/**
	 * Returns the services configuration object for the requested &lt;var&gt;servicesInterface&lt;/var&gt;.
	 *
	 * @param servicesInterface The services interface for which to return its configuration.
	 * @param &lt;S&gt;               Type of the services interface.
	 * @return Configuration object that can be used to configure the desired services.
	 * @see ServicesConfiguration
	 * @see #services(Class)
	 */
	@NonNull
	@SuppressWarnings(&quot;unchecked&quot;)
	public &lt;S&gt; ServicesConfiguration&lt;S&gt; servicesConfiguration(@NonNull final Class&lt;S&gt; servicesInterface) {
<span class="fc" id="L182">		this.ensureHasServicesConfiguration(servicesInterface);</span>
<span class="fc" id="L183">		return mServices.get(servicesInterface);</span>
	}

	/**
	 * Ensures that the services configuration object is created for the given &lt;var&gt;servicesInterface&lt;/var&gt;.
	 *
	 * @param servicesInterface The services interface for which to create new configuration if it
	 *                          is not created yet.
	 */
	private void ensureHasServicesConfiguration(final Class&lt;?&gt; servicesInterface) {
<span class="fc" id="L193">		synchronized (mServices) {</span>
<span class="fc" id="L194">			final ServicesConfiguration servicesConfiguration = mServices.get(servicesInterface);</span>
<span class="fc bfc" id="L195" title="All 2 branches covered.">			if (servicesConfiguration == null) mServices.put(</span>
					servicesInterface,
<span class="fc" id="L197">					onCreateServicesConfiguration(servicesInterface)</span>
			);
<span class="pc" id="L199">		}</span>
<span class="fc" id="L200">	}</span>

	/**
	 * Invoked whenever {@link #servicesConfiguration(Class)} or {@link #services(Class)} is called
	 * for the first time for the specified &lt;var&gt;servicesInterface&lt;/var&gt;.
	 * &lt;p&gt;
	 * Default implementation creates a new instance of ServicesConfiguration with the given services
	 * interface and end point specified for this manager (if any).
	 * &lt;p&gt;
	 * Custom implementations of ServiceManager may override this method to perform default services
	 * configuration for them specific.
	 *
	 * @param servicesInterface Class of the services interface for which to create new configuration
	 *                          object.
	 * @return New services configuration for the services interface.
	 */
	@NonNull
	@CallSuper
	protected ServicesConfiguration onCreateServicesConfiguration(@NonNull final Class&lt;?&gt; servicesInterface) {
<span class="fc" id="L219">		final ServicesConfiguration configuration = new ServicesConfiguration&lt;&gt;(servicesInterface);</span>
<span class="fc bfc" id="L220" title="All 2 branches covered.">		if (mEndPoint != null) configuration.retrofitBuilder().baseUrl(mEndPoint.getBaseUrl());</span>
<span class="fc" id="L221">		return configuration;</span>
	}

	/*
	 * Inner classes ===============================================================================
	 */

	/**
	 * Class used for configuration of a specific Retrofit services interface. Each configuration
	 * object manages a single instance of {@link Retrofit} along with its corresponding
	 * {@link Retrofit.Builder} that are used to build a PROXY instance for services interface for
	 * the current configuration.
	 * &lt;p&gt;
	 * Created instance of services PROXY is cached so it does not need to be created each time it
	 * is requested via {@link ServiceManager#services(Class)}. This instance of PROXY is re-created
	 * only in case where there has been performed some configuration change and {@link #invalidate()}
	 * has been called to indicate the services PROXY is no longer valid.
	 *
	 * @param &lt;S&gt; Type of the services interface specific for this configuration.
	 */
	public static final class ServicesConfiguration&lt;S&gt; {

		/**
		 * Builder used to create an instance of {@link #retrofit} for the current configuration
		 * parameters.
		 */
<span class="fc" id="L247">		private final Retrofit.Builder mBuilder = new Retrofit.Builder();</span>

		/**
		 * Class of services interface used to create {@link #services} PROXY by {@link #retrofit}.
		 */
		private final Class&lt;S&gt; servicesInterface;

		/**
		 * Current instance (if any) of services PROXY created using {@link #retrofit} for the
		 * current configuration.
		 *
		 * @see #services()
		 */
		private S services;

		/**
		 * Retrofit instance created by {@link #mBuilder} for the current configuration parameters.
		 * This retrofit instance is used to create an instance of services PROXY whenever
		 * {@link #services()} is invoked and there has been registered configuration change.
		 *
		 * @see Retrofit#create(Class)
		 */
		private Retrofit retrofit;

		/**
		 * Flag indicating whether this services configuration has changed or not. If {@code true}
		 * the current instance of {@link #retrofit} should be updated the next time services
		 * are requested via {@link #services()}.
		 */
<span class="fc" id="L276">		private volatile boolean changed = true;</span>

		/**
		 * Creates a new instance of ServicesConfiguration for the specified &lt;var&gt;servicesInterface&lt;/var&gt;
		 * class.
		 *
		 * @param servicesInterface Class of the services interface used to create PROXY services
		 *                          instance.
		 */
<span class="fc" id="L285">		ServicesConfiguration(@NonNull final Class&lt;S&gt; servicesInterface) {</span>
<span class="fc" id="L286">			this.servicesInterface = servicesInterface;</span>
<span class="fc" id="L287">		}</span>

		/**
		 * Returns the Retrofit builder that is used to build instance of Retrofit and instance of
		 * services PROXY for this services configuration.
		 * &lt;p&gt;
		 * When any of the current parameters of the builder is changed do not forget to call
		 * {@link #invalidate()} so the change is accepted and new updated services PROXY is created
		 * in next call to {@link ServiceManager#services(Class)}.
		 *
		 * @return Retrofit builder that may be used to configure services PROXY associated with this
		 * configuration and may be obtained via {@link ServiceManager#services(Class)}.
		 */
		@NonNull
		public Retrofit.Builder retrofitBuilder() {
<span class="fc" id="L302">			return mBuilder;</span>
		}

		/**
		 * Returns the Retrofit instance for the current configuration.
		 *
		 * @return Retrofit instance.
		 * @see #retrofitBuilder()
		 * @see #invalidate()
		 */
		@NonNull
		public Retrofit retrofit() {
<span class="fc" id="L314">			this.ensureValid();</span>
<span class="fc" id="L315">			return retrofit;</span>
		}

		/**
		 * Returns the instance of services PROXY created from services interface specified for
		 * this configuration.
		 *
		 * @return Services PROXY configured according to this configuration.
		 */
		@NonNull
		S services() {
<span class="fc" id="L326">			this.ensureValid();</span>
<span class="fc" id="L327">			return services;</span>
		}

		/**
		 * Ensures that the current Retrofit instance and services PROXY are valid according to the
		 * current configuration.
		 */
		private void ensureValid() {
<span class="fc bfc" id="L335" title="All 2 branches covered.">			if (changed) {</span>
<span class="fc" id="L336">				synchronized (mBuilder) {</span>
<span class="fc" id="L337">					this.retrofit = mBuilder.build();</span>
<span class="fc" id="L338">					this.services = retrofit.create(servicesInterface);</span>
<span class="fc" id="L339">					this.changed = false;</span>
<span class="fc" id="L340">				}</span>
			}
<span class="fc" id="L342">		}</span>

		/**
		 * Invalidates the current configuration. Next call to {@link ServiceManager#services(Class)}
		 * with services interface associated with this configuration will create a new instance
		 * of the desired services PROXY.
		 */
		public void invalidate() {
<span class="fc" id="L350">			this.changed = true;</span>
<span class="fc" id="L351">		}</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span>Generated by the Android Gradle plugin 2.3.3</div></body></html>